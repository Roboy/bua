{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Reactive Dialog State Library _ __ _ __ _ ___ ____ __ ______ ______/ /_____/ /___ _ _ / \\/ __ \\/ / / /__ \\/ ___\\, / __ \\, /__ \\ _ _ / /\\/ /_/ /\\ \\/ / /_/ /\\__, / / /_/ / / /_/ / _ \\/ _\\__/\\/ _\\__/ ,___/\\____/\\/\\__/\\/\\/ ,___/ _____ _ _\\____/ _ _\\____/ /_ _\\ 0> 0> \\__\u22bd__/ (C) Roboy 2018 \u22c2 About Ravestate is a reactive library for real-time natural language dialog systems. Dependencies portaudio on macOS In order to install PyAudio with pip, you need to install portaudio first using: brew install portaudio Installation Via PIP The easiest way to install ravestate is through pip: pip install ravestate For developers First, install dependencies: pip install -r requirements.txt # To run tests, install pytest, mocking, fixtures... pip install -r requirements-dev.txt Then, you may open the repository in any IDE, and mark the modules folder as a sources root. Running Hello World Ravestate applications are defined by a configuration, which specifies the ravestate modules that should be loaded. To run the basic hello world application, run ravestate with a config file or command line arguments: Running with command line spec You can easily run a combination of ravestate modules in a shared context, by listing them as arguments to the rasta command, which is installed with ravestate: rasta ravestate_conio ravestate_hello_world Run rasta -h to see more options! Running with config file(s) You may specify a series of config files to configure ravestate context, when specifying everything through the command line becomes too laborious: # In file hello_world.yml module: core config: import: - ravestate_conio - ravestate_hello_world Then, run rasta with this config file: rasta -f hello_world.yml Running tests If you have installed the dependencies from requirements-dev.txt you may run the ravestate test suite as follows: ./run_tests.sh","title":"Home"},{"location":"#welcome-to-the-reactive-dialog-state-library","text":"_ __ _ __ _ ___ ____ __ ______ ______/ /_____/ /___ _ _ / \\/ __ \\/ / / /__ \\/ ___\\, / __ \\, /__ \\ _ _ / /\\/ /_/ /\\ \\/ / /_/ /\\__, / / /_/ / / /_/ / _ \\/ _\\__/\\/ _\\__/ ,___/\\____/\\/\\__/\\/\\/ ,___/ _____ _ _\\____/ _ _\\____/ /_ _\\ 0> 0> \\__\u22bd__/ (C) Roboy 2018 \u22c2","title":"Welcome to the Reactive Dialog State Library"},{"location":"#about","text":"Ravestate is a reactive library for real-time natural language dialog systems.","title":"About"},{"location":"#dependencies","text":"","title":"Dependencies"},{"location":"#portaudio-on-macos","text":"In order to install PyAudio with pip, you need to install portaudio first using: brew install portaudio","title":"portaudio on macOS"},{"location":"#installation","text":"","title":"Installation"},{"location":"#via-pip","text":"The easiest way to install ravestate is through pip: pip install ravestate","title":"Via PIP"},{"location":"#for-developers","text":"First, install dependencies: pip install -r requirements.txt # To run tests, install pytest, mocking, fixtures... pip install -r requirements-dev.txt Then, you may open the repository in any IDE, and mark the modules folder as a sources root.","title":"For developers"},{"location":"#running-hello-world","text":"Ravestate applications are defined by a configuration, which specifies the ravestate modules that should be loaded. To run the basic hello world application, run ravestate with a config file or command line arguments:","title":"Running Hello World"},{"location":"#running-with-command-line-spec","text":"You can easily run a combination of ravestate modules in a shared context, by listing them as arguments to the rasta command, which is installed with ravestate: rasta ravestate_conio ravestate_hello_world Run rasta -h to see more options!","title":"Running with command line spec"},{"location":"#running-with-config-files","text":"You may specify a series of config files to configure ravestate context, when specifying everything through the command line becomes too laborious: # In file hello_world.yml module: core config: import: - ravestate_conio - ravestate_hello_world Then, run rasta with this config file: rasta -f hello_world.yml","title":"Running with config file(s)"},{"location":"#running-tests","text":"If you have installed the dependencies from requirements-dev.txt you may run the ravestate test suite as follows: ./run_tests.sh","title":"Running tests"},{"location":"modules/","text":"ravestate.argparse handle_args handle_args(*args) -> Tuple[List[str], List[Tuple[str, str, Any]], List[str]] Runs an argument parser for the given args. Returns modules-to-load, config value-overrides and config file-pathes. Note: If the arguments are ill-formatted, or the -h argument is passed, help will be printed to the console and the program will abort. :param args: Argument list which will be fed into argparse.parse_args. :return: A Tuple with three items: 1.) A list of module names which should be imported. 2.) A list of tuples, where each tuple is a module name, a config key name, and a value. 3.) A list of yaml file paths. ravestate.constraint s s(signalname: str) Alias to call Signal-constructor :param signalname: Name of the Signal Constraint Constraint(self, /, *args, **kwargs) Superclass for Signal, Conjunct and Disjunct Signal Signal(self, name: str) Class that represents a Signal fulfilled bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed. name str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object. str () (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'. Conjunct Conjunct(self, *args) Class that represents a Conjunction of Signals Disjunct Disjunct(self, *args) Class that represents a Disjunction of Conjunctions ravestate.module Module Module(self, *, name: str, props: List[ravestate.property.PropertyBase] = (), states: List[ravestate.state.State] = (), config: Dict[str, Any] = None) Atomic class, which encapsulates a named set of states, properties and config entries, which form a coherent bundle. ravestate.config Configuration Configuration(self, paths: List[str]) The Configuration class maintains a dictionary of key-value stores, which represent configuration entries for specific named modules. The key-value stores may be successively updated with consecutive yaml files, where each yaml document has the following content: module: module-name config: key-a: value-a key-b: value-b # etc add_conf Configuration.add_conf(self, mod: ravestate.module.Module) Register a set of allowed config entries for a specific module. Correctly typed values for allowed keys, that were previously parsed during construction from the yaml files, will be applied immediately. :param mod: A module object with a name and a conf dict. get_conf Configuration.get_conf(self, module_name: str) Retrieve updated config values for a module that was previously registered with add_conf. :param module_name: The module name for which configuration should be retrieved. :return: A dictionary which contains exactly the keys that were contained in the module configuration dictionary during add_conf, or an empty dictionary if the module name is unknown. get Configuration.get(self, module_name: str, key: str) -> Any Gte the current value of a config entry. :param module_name: The module that provides the config entry. :param key: A config key for the module that was previously added through add_conf. :return: The current value, or None, if the entry does not exist. set Configuration.set(self, module_name: str, key: str, value: Any) Set the current value of a config entry. :param module_name: The module of the config entry. :param key: A config key for the module that was previously added through add_conf. :param value: The new value for the config entry. An error will be raised, if the type of the new value does not match the type of the old value. write Configuration.write(self, path: str) Write all current config entries to a yaml file. :param path: The file path to write. Will be overwritten! read Configuration.read(self, path: str) Loads all documents from a yaml file and tries to interpret them as configuration objects as described above. :param path: The yaml file path from which to load config documents. ravestate.property PropertyBase PropertyBase(self, *, name='', allow_read=True, allow_write=True, allow_push=True, allow_pop=True, allow_delete=True, default=None, always_signal_changed=False) Base class for context properties. Controls read/write/push/pop/delete permissions, property name basic impls. for the property value, parent/child mechanism. read PropertyBase.read(self) Read the current property value. write PropertyBase.write(self, value) Write a new value to the property. :param value: The new value. :return: True if the value has changed and :changed should be signaled, false otherwise. ravestate.receptor receptor receptor(*, ctx_wrap: ravestate.wrappers.ContextWrapper, write) A receptor is a special state which can be invoked from outside, to push values into the context. :param ctx_wrap: A context wrapper as is always given into the state functions as their first argument. :param write: The property, or tuple of properties, which are going to be written. ravestate.registry import_module import_module(*, module_name: str, callback) Called by context to import a particular ravestate python module. :param module_name: The name of the python module to be imported (must be in pythonpath). :param callback: A callback which should be called when a module calls register() while it is being imported. register register(*, name: str = '', props=(), states=(), config=None) May be called to register a named set of states, properties and config entries, which form a coherent bundle. :param name: The name of the module. Will be prefixed to property and signal names like : . :param props: The properties that should be registered. :param states: The states that should be registered. :param config: A dictionary of config entries and their default values, which should be read from the default/user config files. :return: has_module has_module(module_name: str) Check whether a module with a particular name has been registered. :param module_name: The name which should be checked for beign registered. :return: True if a module with the given name has been registered, false otherwise. get_module get_module(module_name: str) Get a registered module with a particular name :param module_name: The name of the moduke which should be retrieved. :return: The module with the given name if it was registered, false if otherwise. ravestate.state StateActivationResult StateActivationResult(self, /, *args, **kwargs) Base class for return values of state activation functions. Delete Delete(self, /, *args, **kwargs) Return an instance of this class, if the invoked state should be deleted. Emit Emit(self, /, *args, **kwargs) Return an instance of this class, if the invoked state's signal should be emitted. state state(*, signal: str = '', write: tuple = (), read: tuple = (), triggers: ravestate.constraint.Constraint = None) Decorator to declare a new state, which may emit a certain signal, write to a certain set of properties (calling set, push, pop, delete), and read from certain properties (calling read). ravestate.wrappers PropertyWrapper PropertyWrapper(self, *, prop: ravestate.property.PropertyBase, ctx: ravestate.icontext.IContext, allow_read, allow_write) Encapsulates a property, and annotates it with additional r/w perms and a context. The context is used to trigger the proper :changed, :pushed, :popped, :deleted signals when the property is accessed. The wrapper also takes care of locking the property when it is supposed to be written to, and freezing the property's value if it is supposed to be read from. get PropertyWrapper.get(self) Read the current property value. set PropertyWrapper.set(self, value) Write a new value to the property. :param value: The new value. :return: True if the value has changed and :changed should be signaled, false otherwise. ContextWrapper ContextWrapper(self, ctx: ravestate.icontext.IContext, st: ravestate.state.State) Encapsulates a context towards a state, only offering properties with permissions as declared by the state beforehand.","title":"Modules"},{"location":"nlp/","text":"ravestate_nlp","title":"NLP"}]}