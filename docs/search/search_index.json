{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"_ __ _ __ _ ___ ____ __ ______ ______/ /_____/ /___ _ _ / \\/ __ \\/ / / / __ \\/ ___\\, / __ \\, /__ \\ _ _ / /\\/ /_/ /\\ \\/ / /_/ /\\__, / / /_/ / / /_/ / _ \\/ _\\__/\\/ _\\__/ ,___/\\____/\\/\\__/\\/\\/ ,___/ _____ _ _\\____/ _ _\\____/ /_ _\\ 0> 0> \\__\u22bd__/ (C) Roboy 2019 \u22c2 About Ravestate is a reactive library for real-time natural language dialog systems. Installation Via PIP The easiest way to install ravestate is through pip: pip install ravestate For developers First, install dependencies: pip install -r requirements.txt # To run tests, install pytest, mocking, fixtures... pip install -r requirements-dev.txt Then, you may open the repository in any IDE, and mark the modules folder as a sources root. Running Hello World Ravestate applications are defined by a configuration, which specifies the ravestate modules that should be loaded. To run the basic hello world application, run ravestate with a config file or command line arguments: Running with command line spec You can easily run a combination of ravestate modules in a shared context, by listing them as arguments to the rasta command, which is installed with ravestate: rasta ravestate_conio ravestate_hello_world Run rasta -h to see more options! Running with config file(s) You may specify a series of config files to configure ravestate context, when specifying everything through the command line becomes too laborious: # In file hello_world.yml module: core config: import: - ravestate_conio - ravestate_hello_world Then, run rasta with this config file: rasta -f hello_world.yml Running tests If you have installed the dependencies from requirements-dev.txt you may run the ravestate test suite as follows: ./run_tests.sh Building/maintaining the docs If you have installed the dependencies from requirements-dev.txt , generate the docs by running this command at project root: git rm -rf docs rm -rf _build docs pydocmd build The structure and content of the docs are defined in the file pydocmd.yml .","title":"Home"},{"location":"#about","text":"Ravestate is a reactive library for real-time natural language dialog systems.","title":"About"},{"location":"#installation","text":"","title":"Installation"},{"location":"#via-pip","text":"The easiest way to install ravestate is through pip: pip install ravestate","title":"Via PIP"},{"location":"#for-developers","text":"First, install dependencies: pip install -r requirements.txt # To run tests, install pytest, mocking, fixtures... pip install -r requirements-dev.txt Then, you may open the repository in any IDE, and mark the modules folder as a sources root.","title":"For developers"},{"location":"#running-hello-world","text":"Ravestate applications are defined by a configuration, which specifies the ravestate modules that should be loaded. To run the basic hello world application, run ravestate with a config file or command line arguments:","title":"Running Hello World"},{"location":"#running-with-command-line-spec","text":"You can easily run a combination of ravestate modules in a shared context, by listing them as arguments to the rasta command, which is installed with ravestate: rasta ravestate_conio ravestate_hello_world Run rasta -h to see more options!","title":"Running with command line spec"},{"location":"#running-with-config-files","text":"You may specify a series of config files to configure ravestate context, when specifying everything through the command line becomes too laborious: # In file hello_world.yml module: core config: import: - ravestate_conio - ravestate_hello_world Then, run rasta with this config file: rasta -f hello_world.yml","title":"Running with config file(s)"},{"location":"#running-tests","text":"If you have installed the dependencies from requirements-dev.txt you may run the ravestate test suite as follows: ./run_tests.sh","title":"Running tests"},{"location":"#buildingmaintaining-the-docs","text":"If you have installed the dependencies from requirements-dev.txt , generate the docs by running this command at project root: git rm -rf docs rm -rf _build docs pydocmd build The structure and content of the docs are defined in the file pydocmd.yml .","title":"Building/maintaining the docs"},{"location":"config/","text":"ravestate.argparse handle_args handle_args(*args) -> Tuple[List[str], List[Tuple[str, str, Any]], List[str]] Runs an argument parser for the given args. Returns modules-to-load, config value-overrides and config file-pathes. Note: If the arguments are ill-formatted, or the -h argument is passed, help will be printed to the console and the program will abort. args : Argument list which will be fed into argparse.parse_args. Returns: A Tuple with three items: 1.) A list of module names which should be imported. 2.) A list of tuples, where each tuple is a module name, a config key name, and a value. 3.) A list of yaml file paths. ravestate.config Configuration Configuration(self, paths: List[str]) The Configuration class maintains a dictionary of key-value stores, which represent configuration entries for specific named modules. The key-value stores may be successively updated with consecutive yaml files, where each yaml document has the following content: module: module-name config: key-a: value-a key-b: value-b # etc add_conf Configuration.add_conf(self, mod: ravestate.module.Module) Register a set of allowed config entries for a specific module. Correctly typed values for allowed keys, that were previously parsed during construction from the yaml files, will be applied immediately. mod : A module object with a name and a conf dict. get_conf Configuration.get_conf(self, module_name: str) Retrieve updated config values for a module that was previously registered with add_conf. module_name : The module name for which configuration should be retrieved. Returns: A dictionary which contains exactly the keys that were contained in the module configuration dictionary during add_conf, or an empty dictionary if the module name is unknown. get Configuration.get(self, module_name: str, key: str) -> Any Gte the current value of a config entry. module_name : The module that provides the config entry. key : A config key for the module that was previously added through add_conf. Returns: The current value, or None, if the entry does not exist. set Configuration.set(self, module_name: str, key: str, value: Any) Set the current value of a config entry. module_name : The module of the config entry. key : A config key for the module that was previously added through add_conf. value : The new value for the config entry. An error will be raised, if the type of the new value does not match the type of the old value. write Configuration.write(self, path: str) Write all current config entries to a yaml file. path : The file path to write. Will be overwritten! read Configuration.read(self, path: str) Loads all documents from a yaml file and tries to interpret them as configuration objects as described above. path : The yaml file path from which to load config documents.","title":"Configuration"},{"location":"context/","text":"ravestate.context startup startup(**kwargs) -> ravestate.constraint.Signal Obtain the startup signal, which is fired once when Context.run() is executed. Hint: All key-word arguments of constraint.s (...) ( min_age , max_age , detached ) are supported. shutdown shutdown(**kwargs) -> ravestate.constraint.Signal Obtain the shutdown signal, which is fired once when Context.shutdown() is called. Hint: All key-word arguments of constraint.s (...) ( min_age , max_age , detached ) are supported. Context Context(self, *arguments) emit Context.emit(self, signal: ravestate.constraint.Signal, parents: Set[ravestate.spike.Spike] = None, wipe: bool = False) -> None Emit a signal to the signal processing loop. Note: The signal will only be processed if run() has been called! signal : The signal to be emitted. parents : The signal's parents, if it is supposed to be integrated into a causal group. wipe : Boolean to control, whether wipe (signal) should be called before the new spike is created. wipe Context.wipe(self, signal: ravestate.constraint.Signal) Delete all spikes for the given signal. Partially fulfilled states that have acquired an affected spike will be forced to reject it. Wiping a parent spike will also wipe all child spikes. signal : The signal for which all existing spikes (and their children) should be invalidated and forgotten. run Context.run(self) -> None Creates a signal processing thread, starts it, and emits the :startup signal. shutting_down Context.shutting_down(self) -> bool Retrieve the shutdown flag value, which indicates whether shutdown() has been called. shutdown Context.shutdown(self) -> None Sets the shutdown flag and waits for the signal processing thread to join. add_module Context.add_module(self, module_name: str) -> None Add a module by python module folder name, or by ravestate module name. module_name : The name of the module to be added. If it is the name of a python module that has not been imported yet, the python module will be imported, and any ravestate modules registered during the python import will also be added to this context. add_state Context.add_state(self, *, st: ravestate.state.State) -> None Add a state to this context. It will be indexed wrt/ the properties/signals it depends on. Error messages will be generated for unknown signals/properties. st : The state which should be added to this context. rm_state Context.rm_state(self, *, st: ravestate.state.State) -> None Remove a state from this context. Note, that any state which is constrained on the signal that is emitted by the deleted state will also be deleted. st : The state to remove. An error message will be generated, if the state was not previously added to this context with add_state(). add_prop Context.add_prop(self, *, prop: ravestate.property.PropertyBase) -> None Add a property to this context. An error message will be generated, if a property with the same name has already been added previously. prop : The property object that should be added. rm_prop Context.rm_prop(self, *, prop: ravestate.property.PropertyBase) -> None Remove a property from this context. Generates error message, if the property was not added with add_prop() to the context previously prop : The property to remove.object conf Context.conf(self, *, mod: str, key: Union[str, NoneType] = None) -> Any Get a single config value, or all config values for a particular module. mod : The module whose configuration should be retrieved. key : A specific config key of the given module, if only a single config value should be retrieved. Returns: The value of a single config entry if key and module are both specified and valid, or a dictionary of config entries if only the module name is specified (and valid). lowest_upper_bound_eta Context.lowest_upper_bound_eta(self, signals: Set[ravestate.constraint.Signal]) -> int Called by activation when it is pressured to resign. The activation wants to know the earliest ETA of one of it's remaining required constraints. Also called by constraint completion algorithm, to figure out the maximum age for a completed constraint. signals : The signals, whose ETA will be calculated, and among the results the minimum ETA will be returned. Returns: Lowest upper bound number of ticks it should take for at least one of the required signals to arrive. Fixed value (1) for now. signal_specificity Context.signal_specificity(self, sig: ravestate.constraint.Signal) -> float Called by state activation to determine it's constraint's specificity. sig : The signal whose specificity should be returned. Returns: The given signal's specificity. reacquire Context.reacquire(self, act: ravestate.iactivation.IActivation, sig: ravestate.constraint.Signal) Called by activation, to indicate, that it needs a new Spike for the specified signal, and should for this purpose be referenced by context. Note: Not thread-safe, sync must be guaranteed by caller. act : The activation that needs a new spike of the specified nature. sig : Signal type for which a new spike is needed. withdraw Context.withdraw(self, act: ravestate.iactivation.IActivation, sig: ravestate.constraint.Signal) Called by activation to make sure that it isn't referenced anymore as looking for the specified signal. This might be, because the activation chose to eliminate itself due to activation pressure, or because one of the activations conjunctions was fulfilled, so it is no longer looking for signals to fulfill the remaining conjunctions. Note: Not thread-safe, sync must be guaranteed by caller. act : The activation that has lost interest in the specified signal. sig : Signal type for which interest is lost. secs_to_ticks Context.secs_to_ticks(self, seconds: float) -> int Convert seconds to an equivalent integer number of ticks, given this context's tick rate. seconds : Seconds to convert to ticks. Returns: An integer tick count. ravestate.spike Spike Spike(self, *, sig: str, parents: Set[ForwardRef('Spike')] = None, consumable_resources: Set[str] = None) This class encapsulates a single spike, to track ... ... it's consumption for different output properties (through CausalGroup ). ... it's offspring instances (causal group -> spikes caused by this spike) causal_group Spike.causal_group(self) -> ravestate.causal.CausalGroup Get this spike's causal group. Returns: This instances causal group. Should never be None. adopt Spike.adopt(self, child: 'Spike') -> None Called in spike constructor, for instances which claim to be caused by this spike. child : The child to add to this spike's causal group. wiped Spike.wiped(self, child: 'ISpike') -> None Called by an offspring signal, to notify the spike that it was wiped, and should therefore be removed from the children set. child : The child to be forgotten. wipe Spike.wipe(self, already_wiped_in_causal_group: bool = False) -> None Called either in Context run loop when the spike is found to be stale (with wiped_in_causal_group=True), or in Context.wipe(spike), or by parent (recursively). After this function is called, the spike should be cleaned up by GC. already_wiped_in_causal_group : Boolean which indicates, whether wiped(spike) must still be called on the group to make sure sure that no dangling references to the spike are maintained by any state activations. has_offspring Spike.has_offspring(self) Called by CausalGroup.stale(spike). Returns: True if the spike has active offspring, false otherwise. tick Spike.tick(self) -> None Increment this spike's age by 1. age Spike.age(self) -> int Obtain this spike's age (in ticks). offspring Spike.offspring(self) -> Generator[ForwardRef('Spike'), NoneType, NoneType] Recursively yields this spike's offspring and it's children's offspring. Returns: All of this spike's offspring spikes. is_wiped Spike.is_wiped(self) Check, whether this spike has been wiped, and should therefore not be acquired anymore. ravestate.activation Activation Activation(self, st: ravestate.state.State, ctx: ravestate.icontext.IContext) Encapsulates the potential activation of a state. Tracks the collection of Spikes to fulfill of the state-defined activation constraints. resources Activation.resources(self) -> Set[str] Return's the set of the activation's write-access property names. specificity Activation.specificity(self) -> float Returns the lowest specificity among the specificity values of the activation's conjunct constraints. The specificity for a single conjunction is calculated as the sum of it's component signal's specificities, which in turn is calculated as one over the signal's subscriber count. dereference Activation.dereference(self, *, spike: Union[ravestate.iactivation.ISpike, NoneType] = None, reacquire: bool = False, reject: bool = False, pressured: bool = False) -> None Notify the activation, that a single or all spike(s) are not available anymore, and should therefore not be referenced anymore by the activation. This is called by ... ... context when a state is deleted. ... causal group, when a referenced signal was consumed for a required property. ... causal group, when a referenced signal was wiped. ... this activation (with reacquire=True and pressured=True), if it gives in to activation pressure. spike : The spike that should be forgotten by the activation, or none, if all referenced spikes should be forgotten. reacquire : Flag which tells the function, whether for every rejected spike, the activation should hook into context for reacquisition of a replacement spike. reject : Flag which controls, whether de-referenced spikes should be explicitely rejected through their causal groups. pressured : Flag which controls, whether de-referencing should only occur for spikes of causal groups in the pressuring_causal_groups set. acquire Activation.acquire(self, spike: ravestate.spike.Spike) -> bool Let the activation acquire a signal it is registered to be interested in. spike : The signal which should fulfill at least one of this activation's signal constraints. Returns: Should return True. secs_to_ticks Activation.secs_to_ticks(self, seconds: float) -> int Convert seconds to an equivalent integer number of ticks, given this activation's tick rate. seconds : Seconds to convert to ticks. Returns: An integer tick count. pressure Activation.pressure(self, give_me_up: ravestate.iactivation.ICausalGroup) Called by CausalGroup, to pressure the activation to make a decision on whether it is going to retain a reference to the given spike, given that there is a lower- specificity activation which is ready to run. give_me_up : Causal group that wishes to be de-referenced by this activation. spiky Activation.spiky(self) -> bool Returns true, if the activation has acquired any spikes at all. Returns: True, if any of this activation's constraint's signal is referencing a spike. update Activation.update(self) -> bool Called once per tick on this activation, to give it a chance to activate itself, or auto-eliminate, or reject spikes which have become too old. Returns: True, if the target state is activated and teh activation be forgotten, false if needs further attention in the form of updates() by context in the future. ravestate.causal CausalGroup CausalGroup(self, resources: Set[str]) Class which represents a causal group graph of spike parent/offspring spikes (a \"superspike\"). These must synchronize wrt/ their (un)written properties and state activation candidates, such that they don't cause output races. Note: Always use a with ... construct to interact with a causal group. Otherwise, undefined behavior may occur due to race conditions. merge CausalGroup.merge(self, other: 'CausalGroup') Merge this causal group with another. Unwritten props will become the set intersection of this group's unwritten props and other's unwritten props. consumed() will be called with all properties that are consumed by other, but not this. Afterwards, other's member objects will be set to this's. acquired CausalGroup.acquired(self, spike: 'ISpike', acquired_by: ravestate.iactivation.IActivation, detached: bool) -> bool Called by Activation to notify the causal group, that it is being referenced by an activation constraint for a certain member spike. spike : State activation instance, which is now being referenced by the specified causal group. acquired_by : State activation instance, which is interested in this property. detached : Tells the causal group, whether the reference is detached, and should therefore receive special treatment. Returns: Returns True if all of the acquiring's write-props are free, and the group now refs. the activation, False otherwise. rejected CausalGroup.rejected(self, spike: 'ISpike', rejected_by: ravestate.iactivation.IActivation, reason: int) -> None Called by a state activation, to notify the group that a member spike is no longer being referenced for the given state's write props. This may be because ... ... the state activation's dereference function was called. (reason=0) ... the spike got too old. (reason=1) ... the activation is happening and dereferencing it's spikes. (reason=2) spike : The member spike whose ref-set should be reduced. rejected_by : State activation instance, which is no longer interested in this property. reason : See about. consent CausalGroup.consent(self, ready_suitor: ravestate.iactivation.IActivation) -> bool Called by constraint, to inquire whether this causal group would happily be consumed for the given state activation's properties. This will be called periodically on the group by state activations that are ready to go. Therefore, a False return value from this function is never a final judgement (more like a \"maybe later\"). ready_suitor : The state activation which would like to consume this instance for it's write props. Returns: True if this instance agrees to proceeding with the given consumer for the consumer's write props, False otherwise. activated CausalGroup.activated(self, act: ravestate.iactivation.IActivation) Called by activation which previously received a go-ahead from consent(), when it is truly proceeding with running (after it got the go-ahead from all it's depended=on causal groups). act : The activation that is now running. resigned CausalGroup.resigned(self, act: ravestate.iactivation.IActivation) -> None Called by activation, to let the causal group know that it failed, and a less specific activation may now be considered for the resigned state's write props. act : The activation that is unexpectedly not consuming it's resources, because it's state resigned/failed. consumed CausalGroup.consumed(self, resources: Set[str]) -> None Called by activation to notify the group, that it has been consumed for the given set of properties. resources : The properties which have been consumed. wiped CausalGroup.wiped(self, spike: 'ISpike') -> None Called by a spike, to notify the causal group that the instance was wiped and should no longer be remembered. spike : The instance that should be henceforth forgotten. stale CausalGroup.stale(self, spike: 'ISpike') -> bool Determine, whether a spike is stale (has no remaining interested activations and no children). Returns: True, if no activations reference the given spike for any unwritten property. False otherwise.","title":"Context"},{"location":"modules/","text":"ravestate.module Module Module(self, *, name: str, config: Dict[str, Any] = None) Atomic class, which encapsulates a named set of states, properties and config entries, which form a coherent bundle. registered_modules dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's (key, value) pairs dict(iterable) -> new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -> new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2) import_module import_module(*, module_name: str, callback) Called by context to import a particular ravestate python module. module_name : The name of the python module to be imported (must be in pythonpath). callback : A callback which should be called when a module calls register() while it is being imported. has_module has_module(module_name: str) Check whether a module with a particular name has been registered. module_name : The name which should be checked for beign registered. Returns: True if a module with the given name has been registered, false otherwise. get_module get_module(module_name: str) Get a registered module with a particular name module_name : The name of the moduke which should be retrieved. Returns: The module with the given name if it was registered, false if otherwise.","title":"Modules"},{"location":"properties/","text":"ravestate.property changed changed(property_name, **kwargs) -> ravestate.constraint.Signal Returns the changed Signal for the given property. This signal is emitted, when the Property is written to, and the new property value is different from the old one, or the propertie's always_signal_changed flag is True. Hint: All key-word arguments of constraint.s (...) ( min_age , max_age , detached ) are supported. pushed pushed(property_name, **kwargs) -> ravestate.constraint.Signal Returns the pushed Signal for the given property. This signal is emitted, when a new child property is added to it. From the perspective of a state, this can be achieved with the ContextWrapper.push(...) function. Hint: All key-word arguments of constraint.s (...) ( min_age , max_age , detached ) are supported. popped popped(property_name, **kwargs) -> ravestate.constraint.Signal Returns the popped Signal for the given property. This signal is emitted, when a child property removed from it. From the perspective of a state, this can be achieved with the ContextWrapper.pop(...) function. Hint: All key-word arguments of constraint.s (...) ( min_age , max_age , detached ) are supported. PropertyBase PropertyBase(self, *, name='', allow_read=True, allow_write=True, allow_push=True, allow_pop=True, default_value=None, always_signal_changed=False, is_flag_property=False) Base class for context properties. Controls read/write/push/pop/delete permissions, property name basic impls. for the property value, parent/child mechanism. set_parent_path PropertyBase.set_parent_path(self, path) Set the ancestors (including modulename) for a property path : ancestry in the form of modulename:parent_prop_name (or simply modulename) gather_children PropertyBase.gather_children(self) -> List[ForwardRef('PropertyBase')] Collect this property, and all of it's children. read PropertyBase.read(self) Read the current property value write PropertyBase.write(self, value) Write a new value to the property value : The new value. Returns: True if the value has changed and :changed should be signaled, false otherwise. push PropertyBase.push(self, child: 'PropertyBase') Add a child to the property child : The child object Returns: True if the child was added successfully, false otherwise. pop PropertyBase.pop(self, child_name: str) Remove a child from the property by it's name. child_name : Name of the child to be removed. Returns: True if the pop was successful, False otherwise changed_signal PropertyBase.changed_signal(self) -> ravestate.constraint.Signal Signal that is emitted by PropertyWrapper when write() returns True. pushed_signal PropertyBase.pushed_signal(self) -> ravestate.constraint.Signal Signal that is emitted by PropertyWrapper when push() returns True. popped_signal PropertyBase.popped_signal(self) -> ravestate.constraint.Signal Signal that is emitted by PropertyWrapper when pop() returns True. flag_true_signal PropertyBase.flag_true_signal(self) -> ravestate.constraint.Signal Signal that is emitted by PropertyWrapper when it is a flag-property and self.value is set to True. flag_false_signal PropertyBase.flag_false_signal(self) -> ravestate.constraint.Signal Signal that is emitted by PropertyWrapper when it is a flag-property and self.value is set to False. signals PropertyBase.signals(self) -> Generator[ravestate.constraint.Signal, NoneType, NoneType] Yields all signals that may be emitted because of this property, given it's write/push/pop permissions.","title":"Properties"},{"location":"states/","text":"ravestate.state Delete Delete(self, resign: bool = False) Return an instance of this class, if the invoked state should be deleted. resign : Set to true, if the state being deleted is due to it failing to execute, so a resignation is implied. This means, that the spikes that were allocated for it's activation may be re-used by another state. Wipe Wipe(self, /, *args, **kwargs) Return an instance of this class, if context.wipe(signal) should be called, to ensure that there are no more active spikes for the state's signal. Emit Emit(self, wipe: bool = False) Return an instance of this class, if the invoked state's signal should be emitted. wipe : Set to true, if context.wipe(signal) should be called before emit, to ensure that there is only one free spike for the given signal. Resign Resign(self, /, *args, **kwargs) Return an instance of this class, if the state invocation should be regarded unsuccessful. This means, that the state's signal will not be emitted, and the spikes that were allocated for it's activation may be re-used by another state. state state(*, signal_name: Union[str, NoneType] = '', write: tuple = (), read: tuple = (), cond: ravestate.constraint.Constraint = None, emit_detached=False) Decorator to declare a new state, which may emit a certain signal, write to a certain set of properties (calling write, push, pop), and read from certain properties (calling read). ravestate.constraint ConfigurableAge ConfigurableAge(self, key: str) Class for having min/max_age parameters for Constraints configurable with a config key key str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object. str () (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'. s s(signal_name: str, *, min_age: Union[float, ravestate.constraint.ConfigurableAge] = 0.0, max_age: Union[float, ravestate.constraint.ConfigurableAge] = 5.0, detached: bool = False) -> 'Signal' Alias to call Signal-constructor signal_name : Name of the Signal min_age : Minimum age for the signal, in seconds. Can also be ConfigurableAge that gets the age from the config. max_age : Maximum age for the signal, in seconds. Can also be ConfigurableAge that gets the age from the config. Set to less-than zero for unrestricted age. detached : Flag which indicates, whether spikes that fulfill this signal are going to have a separate causal group from spikes that are generated by a state that uses this signal as a constraint. Constraint Constraint(self, /, *args, **kwargs) Superclass for Signal, Conjunct and Disjunct Signal Signal(self, name: str, *, min_age=0.0, max_age=5.0, detached=False) Class that represents a Signal Conjunct Conjunct(self, *args) Class that represents a Conjunction of Signals Disjunct Disjunct(self, *args) Class that represents a Disjunction of Conjunctions ravestate.receptor receptor receptor(*, ctx_wrap: ravestate.wrappers.ContextWrapper, write: Union[str, Tuple[str]]) A receptor is a special state which can be invoked from outside, to push values into the context. ctx_wrap : A context wrapper as is always given into the state functions as their first argument. write : The property, or tuple of properties, which are going to be written.","title":"States"}]}